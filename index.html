<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        * { margin: 0; padding: 0; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        video { display: block; width: 100vw; height: 100vh; object-fit: contain; background: #000; }
        #status {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #888; font: 24px sans-serif; text-align: center;
        }
    </style>
</head>
<body>
    <video id="display" autoplay muted playsinline></video>
    <div id="status">Waiting for session...</div>

    <!-- Cast Receiver SDK -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <!-- SignalR + MessagePack -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/msgpack5@6.0.2/dist/msgpack5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr-protocol-msgpack@8.0.0/dist/browser/signalr-protocol-msgpack.min.js"></script>

    <script>
    'use strict';
    const VERSION = 4;

    // --- Remote logging: forward console output to server ---
    let _logHubUrl = null;
    function remoteLog(level, args) {
        if (!_logHubUrl) return;
        const msg = args.map(a => {
            try { return typeof a === 'string' ? a : JSON.stringify(a); }
            catch { return String(a); }
        }).join(' ');
        fetch(`${_logHubUrl}/api/cast/log`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ level, message: msg })
        }).catch(() => {});
    }
    const _origLog = console.log, _origWarn = console.warn, _origError = console.error;
    console.log = (...a) => { _origLog(...a); remoteLog('info', a); };
    console.warn = (...a) => { _origWarn(...a); remoteLog('warn', a); };
    console.error = (...a) => { _origError(...a); remoteLog('error', a); };
    window.addEventListener('error', e => remoteLog('error', [`Uncaught: ${e.message} at ${e.filename}:${e.lineno}`]));
    window.addEventListener('unhandledrejection', e => remoteLog('error', [`Unhandled rejection: ${e.reason}`]));

    console.log(`[PhoneMirror Cast Receiver v${VERSION}]`);

    const videoEl = document.getElementById('display');
    const statusEl = document.getElementById('status');
    const MSE = window.MediaSource || window.ManagedMediaSource;

    // --- MSE fMP4 renderer ---

    let mediaSource = null;
    let sourceBuffer = null;
    let objectUrl = null;
    let appendQueue = [];
    let isAppending = false;
    let framesReceived = 0;
    let connection = null;

    function initMSE() {
        if (mediaSource && mediaSource.readyState === 'open') {
            try {
                if (sourceBuffer) mediaSource.removeSourceBuffer(sourceBuffer);
                mediaSource.endOfStream();
            } catch (e) {}
        }
        if (objectUrl) {
            URL.revokeObjectURL(objectUrl);
            objectUrl = null;
        }
        sourceBuffer = null;
        mediaSource = null;
        isAppending = false;
        appendQueue = [];
        framesReceived = 0;

        mediaSource = new MSE();
        objectUrl = URL.createObjectURL(mediaSource);
        videoEl.src = objectUrl;

        mediaSource.addEventListener('sourceopen', () => {
            try {
                const codecs = ['avc1.42E01E', 'avc1.4D0029', 'avc1.640029'];
                const codec = codecs.find(c => MSE.isTypeSupported(`video/mp4; codecs="${c}"`)) || 'avc1.42E01E';
                const mimeType = `video/mp4; codecs="${codec}"`;
                console.log('MSE sourceopen, codec:', mimeType);

                sourceBuffer = mediaSource.addSourceBuffer(mimeType);
                sourceBuffer.mode = 'segments';
                sourceBuffer.addEventListener('updateend', () => {
                    isAppending = false;
                    processQueue();
                });
                sourceBuffer.addEventListener('error', (e) => {
                    console.error('SourceBuffer error:', e);
                    isAppending = false;
                });
                processQueue();
            } catch (e) {
                console.error('Failed to create SourceBuffer:', e);
                statusEl.textContent = 'MSE error: ' + e.message;
                statusEl.style.display = '';
            }
        });
    }

    function processQueue() {
        if (isAppending || !sourceBuffer || appendQueue.length === 0) return;
        if (appendQueue.length > 5) {
            console.warn(`Queue overflow (${appendQueue.length}), dropping`);
            appendQueue = appendQueue.slice(-2);
        }
        isAppending = true;
        try {
            sourceBuffer.appendBuffer(appendQueue.shift());
        } catch (e) {
            console.error('appendBuffer error:', e);
            isAppending = false;
        }
    }

    function trimBuffer() {
        if (!sourceBuffer || sourceBuffer.updating || !videoEl.currentTime) return;
        try {
            const buffered = sourceBuffer.buffered;
            if (buffered.length > 0 && videoEl.currentTime - buffered.start(0) > 5) {
                sourceBuffer.remove(buffered.start(0), videoEl.currentTime - 1);
            }
        } catch (e) {}
    }

    function renderFrame(frame) {
        const data = frame.data;
        if (!data || data.length === 0) return;

        const bytes = data instanceof Uint8Array ? data
            : data instanceof ArrayBuffer ? new Uint8Array(data)
            : data;

        appendQueue.push(bytes);
        processQueue();

        framesReceived++;
        if (framesReceived === 1) {
            statusEl.style.display = 'none';
            console.log('First frame received');
        }

        // Trim old buffer data every 60 frames
        if (framesReceived % 60 === 0) trimBuffer();

        // Chase live edge on every frame
        chaseLiveEdge();
    }

    function chaseLiveEdge() {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0) return;
        const end = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        const lag = end - videoEl.currentTime;

        if (lag > 0.8) {
            // Way behind — jump to near live
            videoEl.currentTime = end - 0.05;
            videoEl.playbackRate = 1.0;
        } else if (lag > 0.3) {
            // Drifting behind — speed up to catch up smoothly
            videoEl.playbackRate = 1.1;
        } else {
            videoEl.playbackRate = 1.0;
        }
    }

    // --- Connect to PhoneMirror server ---

    async function startSession(hubUrl, deviceId, sourceId) {
        console.log(`Connecting to ${hubUrl}/mirrorHub for ${deviceId}/${sourceId}`);
        statusEl.textContent = 'Connecting to server...';

        const connBuilder = new signalR.HubConnectionBuilder()
            .withUrl(`${hubUrl}/mirrorHub`)
            .withAutomaticReconnect();

        if (signalR.protocols && signalR.protocols.msgpack) {
            connBuilder.withHubProtocol(new signalR.protocols.msgpack.MessagePackHubProtocol());
        }

        connection = connBuilder.build();

        connection.on('ReceiveFrame', renderFrame);

        connection.onreconnected(async () => {
            console.log('Reconnected, rejoining session');
            framesReceived = 0;
            statusEl.textContent = 'Reconnecting...';
            statusEl.style.display = '';
            initMSE();
            try {
                await connection.invoke('StartMirroring', deviceId, sourceId, 'fmp4', 'off', null);
            } catch (e) {
                console.error('Rejoin failed:', e);
            }
        });

        try {
            await connection.start();
            console.log('SignalR connected');
            statusEl.textContent = 'Starting mirror...';
            initMSE();
            await connection.invoke('StartMirroring', deviceId, sourceId, 'fmp4', 'off', null);
            console.log('StartMirroring invoked');
        } catch (e) {
            console.error('Connection failed:', e);
            statusEl.textContent = 'Connection failed: ' + e.message;
            statusEl.style.display = '';
        }
    }

    // --- Cast Receiver: listen for session info via CASTV2 ---

    if (!MSE) {
        statusEl.textContent = 'MediaSource API not available';
    } else {
        const castCtx = cast.framework.CastReceiverContext.getInstance();
        const NS = 'urn:x-cast:com.phonemirror.session';

        castCtx.addCustomMessageListener(NS, (event) => {
            console.log('CASTV2 message received:', JSON.stringify(event.data));
            const { hubUrl, deviceId, sourceId } = event.data;
            if (hubUrl && deviceId && sourceId) {
                _logHubUrl = hubUrl;
                startSession(hubUrl, deviceId, sourceId);
            }
        });

        castCtx.start({
            disableIdleTimeout: true,
            customNamespaces: { [NS]: cast.framework.system.MessageType.JSON }
        });

        console.log('Cast receiver started, waiting for session message...');
    }
    </script>
</body>
</html>
